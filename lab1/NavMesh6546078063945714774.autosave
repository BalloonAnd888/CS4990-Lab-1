// Useful to sort lists by a custom key
import java.util.Comparator;
import java.util.Stack;

/// In this file you will implement your navmesh and pathfinding.

/// This node representation is just a suggestion
class Node
{
  int id;
  ArrayList<Wall> polygon;
  PVector center;
  ArrayList<Node> neighbors;
  ArrayList<Wall> connections;
}



class NavMesh
{
  ArrayList<Node> nodes;
  ArrayList<PVector> reflex;
  int currentIndex = -1;

  NavMesh() {
    nodes = new ArrayList<>();
  }

  void bake(Map map)
  {
    /// generate the graph you need for pathfinding

    // Identify corners of the walkable area (defined as polygon outline)
    ArrayList<Wall> corners = new ArrayList<>(map.outline);
    System.out.println("Vertices");
    for (Wall wall : corners) {
      PVector start = wall.start;
      PVector end = wall.end;

      System.out.println("Start: " + start.x + ", " + start.y);
      System.out.println("End: " + end.x + ", " + end.y);
      System.out.println("Direction: " + wall.direction);
    }

    // Split the polygon until all polygons are convex
    ArrayList<ArrayList<Wall>> polygons = splitIntoConvexPolygons(corners);

    for (ArrayList<Wall> polygon : polygons) {
      Node node = new Node();
      node.polygon = polygon;
      //node.center = calculateCentroid(polygon);
      node.neighbors = new ArrayList<>();
      nodes.add(node);
    }


    // For each non-convex corner, add edges to split polygon into convex polygons,
    // find corner to add edge and check the new polygon to see if there's a reflex angle

    // Draw a line that splits the polygon into two parts
    // Repeate until all polygons are convex
    // Create a graph where each node represents a convex polygon
    // Two nodes are connected by an edge if the polygons share a border (common edge)
    // Find midpoint of shared edges
    // If obstacles are present, extend outline of map by connecting the obstacle vertices to the outer edges of the map
  }

  ArrayList<ArrayList<Wall>> splitIntoConvexPolygons(ArrayList<Wall> corners) {
    ArrayList<ArrayList<Wall>> polygons = new ArrayList<>();
    Stack<ArrayList<Wall>> stack = new Stack<>();

    // Initialize the stack with the original polygon
    stack.push(new ArrayList<>(corners));

    while (!stack.isEmpty()) {
      ArrayList<Wall> current = stack.pop();
      ArrayList<PVector> reflexCorners = new ArrayList<>();

      System.out.println("\nCurrent Map");
      for (Wall wall : current) {
        System.out.println("Side");
        System.out.println(wall.start);
        System.out.println(wall.end + "\n");
      }

      // Find all reflex angles
      reflexCorners = findReflexAngles(current);

      for (PVector rc : reflexCorners) {
        System.out.println("RC: " + rc);
      }

      for (PVector reflexCorner : reflexCorners) {
        Wall edge = createEdge(reflexCorner, current, map);
        //System.out.println(edge);
        System.out.println("Edge:");
        System.out.println("Start: " + edge.start);
        System.out.println("End: " + edge.end);
        if (edge != null) {
          ArrayList<Wall> newPolygon = splitPolygon(current, reflexCorner, edge);
          System.out.print("New Polygon\n");
          for (Wall wall : newPolygon) {
            System.out.print("Side\n");
            System.out.println("Start: " + wall.start);
            System.out.println("End: " + wall.end);
          }

          if (!newPolygon.isEmpty()) {
            if (isConvexPolygon(newPolygon)) {
              polygons.add(newPolygon);
            } else {
              stack.push(newPolygon); // Add the new polygon for further processing
              System.out.println("\nStack");
              for (ArrayList<Wall> s : stack) {
                System.out.println("\nStack Polygon");
                for (Wall wall : s) {
                  System.out.println("Side");
                  System.out.println(wall.start);
                  System.out.println(wall.end + "\n");
                }
              }
            }
          }

          System.out.println(isConvexPolygon(newPolygon));

          updateCurrent(current, newPolygon, edge);

          if (isConvexPolygon(current)) {
            polygons.add(current);
          } else {
            stack.push(current);
          }

          //System.out.println("\nCurrent Map");
          //for (Wall wall : current) {
          //  System.out.println("Side");
          //  System.out.println(wall.start);
          //  System.out.println(wall.end + "\n");
          //}
        }
      }
    }

    System.out.println("\nList of Convex Polygons");
    for (ArrayList<Wall> polygon : polygons) {
      System.out.println("\nConvex Polygon");
      for (Wall wall : polygon) {
        System.out.println("Side");
        System.out.println(wall.start);
        System.out.println(wall.end + "\n");
      }
    }

    //System.out.println("\nCurrent Map");
    //for (Wall wall : current) {
    //  System.out.println("Side");
    //  System.out.println(wall.start);
    //  System.out.println(wall.end + "\n");
    //}

    return polygons;
  }

  //ArrayList<ArrayList<Wall>> splitIntoConvexPolygons(ArrayList<Wall> corners) {
  //  ArrayList<ArrayList<Wall>> polygons = new ArrayList<>();
  //  Stack<ArrayList<Wall>> stack = new Stack<>();

  //  // Initialize the stack with the original polygon
  //  stack.push(new ArrayList<>(corners));

  //  while (!stack.isEmpty()) {
  //    ArrayList<Wall> current = stack.pop();
  //    ArrayList<PVector> reflexCorners = new ArrayList<>();

  //    // Find all reflex angles
  //    reflexCorners = findReflexAngles(current);

  //    for (PVector rc : reflexCorners) {
  //      System.out.println("RC: " + rc);
  //    }

  //    for (PVector reflexCorner : reflexCorners) {
  //      Wall edge = createEdge(reflexCorner, current, map);

  //      if (edge != null) {
  //        ArrayList<Wall> newPolygon = splitPolygon(current, reflexCorner, edge);

  //        if (!newPolygon.isEmpty()) {
  //          if (isConvexPolygon(newPolygon)) {
  //            polygons.add(newPolygon);
  //          } else {
  //            stack.push(newPolygon); // Add the new polygon for further processing
  //          }
  //        }

  //        System.out.println(isConvexPolygon(newPolygon));

  //        updateCurrent(current, newPolygon, edge);

  //        if (isConvexPolygon(current)) {
  //          polygons.add(current);
  //        } else {
  //          stack.push(current);
  //        }
  //      }
  //    }
  //  }

  //  System.out.println("\nList of Convex Polygons");
  //  for (ArrayList<Wall> polygon : polygons) {
  //    System.out.println("\nConvex Polygon");
  //    for (Wall wall : polygon) {
  //      System.out.println("Side");
  //      System.out.println(wall.start);
  //      System.out.println(wall.end + "\n");
  //    }
  //  }

  //  return polygons;
  //}



  //ArrayList<ArrayList<Wall>> splitIntoConvexPolygons(ArrayList<Wall> corners) {
  //  ArrayList<ArrayList<Wall>> polygons = new ArrayList<>();
  //  Stack<ArrayList<Wall>> stack = new Stack<>();

  //  // Initialize the stack with the original polygon
  //  stack.push(new ArrayList<>(corners));


  //  ArrayList<Wall> current = stack.pop();
  //  ArrayList<PVector> reflexCorners = new ArrayList<>();

  //  System.out.println("\nCurrent Map");
  //  for (Wall wall : current) {
  //    System.out.println("Side");
  //    System.out.println(wall.start);
  //    System.out.println(wall.end + "\n");
  //  }

  //  // Find all reflex angles
  //  reflexCorners = findReflexAngles(current);

  //  for (PVector rc : reflexCorners) {
  //    System.out.println("RC: " + rc);
  //  }

  //  for (PVector reflexCorner : reflexCorners) {
  //    Wall edge = createEdge(reflexCorner, current, map);
  //    //System.out.println(edge);
  //    System.out.println("Edge:");
  //    System.out.println("Start: " + edge.start);
  //    System.out.println("End: " + edge.end);
  //    if (edge != null) {
  //      ArrayList<Wall> newPolygon = splitPolygon(current, reflexCorner, edge);
  //      System.out.print("New Polygon\n");
  //      for (Wall wall : newPolygon) {
  //        System.out.print("Side\n");
  //        System.out.println("Start: " + wall.start);
  //        System.out.println("End: " + wall.end);
  //      }

  //      if (!newPolygon.isEmpty()) {
  //        if (isConvexPolygon(newPolygon)) {
  //          polygons.add(newPolygon);
  //        } else {
  //          stack.push(newPolygon); // Add the new polygon for further processing
  //          System.out.println("\nStack");
  //          for (ArrayList<Wall> s : stack) {
  //            System.out.println("\nStack Polygon");
  //            for (Wall wall : s) {
  //              System.out.println("Side");
  //              System.out.println(wall.start);
  //              System.out.println(wall.end + "\n");
  //            }
  //          }
  //        }
  //      }

  //      System.out.println(isConvexPolygon(newPolygon));

  //      updateCurrent(current, newPolygon, edge);

  //      if (isConvexPolygon(current)) {
  //        polygons.add(current);
  //      } else {
  //        stack.push(current);
  //      }

  //      System.out.println("\nCurrent Map");
  //      for (Wall wall : current) {
  //        System.out.println("Side");
  //        System.out.println(wall.start);
  //        System.out.println(wall.end + "\n");
  //      }
  //    }
  //  }


  //  System.out.println("\nList of Convex Polygons");
  //  for (ArrayList<Wall> polygon : polygons) {
  //    System.out.println("\nConvex Polygon");
  //    for (Wall wall : polygon) {
  //      System.out.println("Side");
  //      System.out.println(wall.start);
  //      System.out.println(wall.end + "\n");
  //    }
  //  }

  //  //System.out.println("\nCurrent Map");
  //  //for (Wall wall : current) {
  //  //  System.out.println("Side");
  //  //  System.out.println(wall.start);
  //  //  System.out.println(wall.end + "\n");
  //  //}

  //  return polygons;
  //}

  void updateCurrent(ArrayList<Wall> current, ArrayList<Wall> newPolygon, Wall edge) {
    int currentIndex = -1;
    boolean gotIndex = false;

    for (Wall wall : newPolygon) {
      if (!wall.equals(edge)) {
        if (!gotIndex) {
          currentIndex = current.indexOf(wall);
          System.out.println("Index: " + currentIndex);
          current.remove(wall);
          gotIndex = true;
        } else {
          current.remove(wall);
        }
      }
    }

    if (currentIndex == 0) {
      current.add(currentIndex, new Wall(edge.end, edge.start));
    } else if (current.get(currentIndex-1).direction.x > 0) {
      if (current.get(currentIndex - 1).end.equals(edge.end)) {
        current.add(currentIndex, new Wall(edge.end, edge.start));
      } else {
        current.add(currentIndex, new Wall(edge.start, edge.end));
      }
    } else {
      current.add(currentIndex, new Wall(edge.end, edge.start));
    }
  }


  ArrayList<Wall> splitPolygon(ArrayList<Wall> polygon, PVector reflexCorner, Wall edge) {
    ArrayList<Wall> newPolygon = new ArrayList<>();
    boolean split = false;

    for (Wall wall : polygon) {
      if (wall.start.equals(edge.start) || wall.start.equals(edge.end)) {
        split = true;
      }

      if (split) {
        newPolygon.add(wall);
        if (wall.end.equals(edge.start)) {
          newPolygon.add(edge);
          break;
        } else if (wall.end.equals(edge.end)) {
          newPolygon.add(new Wall(edge.end, edge.start));
          break;
        }
      }
    }

    return newPolygon;
  }

  Wall createEdge(PVector reflex, ArrayList<Wall> polygon, Map map) {
    Wall edge = null;
    float distance = Float.MAX_VALUE;

    for (Wall wall : polygon) {
      PVector candidate = wall.start;
      System.out.println("Candidate: " + candidate);
      //System.out.println(!intersects(reflex, candidate, wall.start, wall.end));
      //System.out.println(reflex.equals(candidate));

      // Check if the edge collides with a wall
      if (!reflex.equals(candidate) &&
        !intersects(reflex, candidate, wall.start, wall.end) &&
        distance > PVector.dist(reflex, candidate) &&
        !isOriginalWall(reflex, candidate, polygon) &&
        //isPointInPolygon(getRandomPoint(new Wall(reflex, candidate)), polygon)
        isPointInPolygon(new PVector(random(reflex.x, candidate.x), random(reflex.y, candidate.y)), polygon)
        ) {
        System.out.println("New Wall");
        distance = PVector.dist(reflex, candidate);
        edge = new Wall(reflex, candidate); // Create the edge
      }
      //if (!reflex.equals(candidate) && wall.crosses(candidate, reflex)) {
      //  System.out.println("New Wall");
      //  return new Wall(reflex, candidate);  // Create the edge
      //}
    }
    if (edge != null) {
      System.out.println("Shortest Edge: " + distance);
    }
    return edge;
  }

  boolean isOriginalWall(PVector reflex, PVector candidate, ArrayList<Wall> polygon) {
    for (Wall wall : polygon) {
      // Check if either (reflex, candidate) or (candidate, reflex) matches an existing wall
      if ((wall.start.equals(reflex) && wall.end.equals(candidate)) ||
        (wall.start.equals(candidate) && wall.end.equals(reflex))) {
        return true;
      }
    }
    return false;
  }

  boolean intersects(PVector p1, PVector p2, PVector p3, PVector p4) {
    PVector d1 = PVector.sub(p2, p1).normalize();
    PVector d2 = PVector.sub(p4, p3).normalize();

    float dist1 = d1.dot(PVector.sub(p3, p1).normalize());
    float dist2 = d1.dot(PVector.sub(p4, p1).normalize());
    float dist3 = d2.dot(PVector.sub(p1, p3).normalize());
    float dist4 = d2.dot(PVector.sub(p2, p3).normalize());

    return (dist1 * dist2 < 0 && dist3 * dist4 < 0);
  }

  boolean isConvexPolygon(ArrayList<Wall> corners) {
    for (int i = 0; i < corners.size(); i++) {
      Wall current = corners.get(i);
      Wall next = corners.get((i + 1) % corners.size());
      Wall previous = corners.get((i - 1 + corners.size()) % corners.size());

      if (isReflex(current, next, previous)) {
        return false;
      }
    }

    return true;
  }

  ArrayList<PVector> findReflexAngles(ArrayList<Wall> corners) {
    // Determine which corners are non-convex (concave) by checking if the angle is > 180
    // a.normal.dot(b.direction)
    reflex = new ArrayList<>();
    for (int i = 0; i < corners.size(); i++) {
      Wall current = corners.get(i);
      Wall next = corners.get((i + 1) % corners.size());
      Wall previous = corners.get((i - 1 + corners.size()) % corners.size());

      //System.out.println("Current Wall: " + current.start + current.end);
      //System.out.println("Next Wall: " + next.start + next.end);
      //System.out.println("Previous Wall: " + previous.start + previous.end);

      if (isReflex(current, next, previous)) {
        reflex.add(current.start);
        System.out.println("Reflex Angle Found");
      }
    }

    return reflex;
  }

  boolean isReflex(Wall current, Wall next, Wall previous) {

    float dotProduct = previous.normal.dot(current.direction);

    if (dotProduct > 0) {
      return true;
    }

    return false;
  }

  ArrayList<PVector> findPath(PVector start, PVector destination)
  {
    /// implement A* to find a path
    ArrayList<PVector> result = null;
    return result;
  }


  void update(float dt)
  {
    draw();
  }

  void draw()
  {
    /// use this to draw the nav mesh graph
    stroke(255);
    for (Node node : nodes) {
      for (Wall wall : node.polygon) {
        line(wall.start.x, wall.start.y, wall.end.x, wall.end.y);
      }
    }

    fill(255, 0, 0);
    for (PVector reflex : reflex) {
      ellipse(reflex.x, reflex.y, 12, 12);
    }
  }
}
